<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" /> <title>Sp1Dy_Gamerâ„¢ Tetris</title> <style> body { background: linear-gradient(to bottom, #0f0f0f, #1a1a1a); color: #00ffe0; font-family: 'Orbitron', sans-serif; text-align: center; margin: 0; padding: 0; overflow-x: hidden; touch-action: none; -webkit-user-select: none; -webkit-touch-callout: none; } canvas { background: #111; display: block; margin: 20px auto; border: 3px solid #00ffe0; box-shadow: 0 0 20px #00ffe0; max-width: 90vw; height: auto; touch-action: none; } h1 { margin-top: 20px; font-size: 2.5em; color: #ff0055; text-shadow: 0 0 10px #ff0055; } #score, #level { font-size: 1.2em; margin-top: -10px; color: #fff; } #branding { margin-top: 10px; font-size: 0.9em; color: #888; } #restartButton, #pauseButton { margin-top: 15px; padding: 10px 20px; font-size: 1em; background-color: #ff0055; color: #fff; border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 0 10px #ff0055; transition: background-color 0.3s ease; } #restartButton:hover, #pauseButton:hover { background-color: #e6004c; } #gameOverScreen { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); border: 3px solid #ff0055; box-shadow: 0 0 20px #ff0055; padding: 30px 50px; color: #ff0055; font-family: 'Orbitron', sans-serif; font-size: 1.5em; text-align: center; display: none; z-index: 1000; border-radius: 10px; width: 90vw; max-width: 400px; } #gameOverScreen button { margin-top: 20px; padding: 10px 25px; font-size: 1.2em; background-color: #ff0055; color: #fff; border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 0 10px #ff0055; transition: background-color 0.3s ease; } #gameOverScreen button:hover { background-color: #e6004c; } #controlsContainer { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; max-width: 600px; margin: 20px auto; } #desktopControls { display: flex; gap: 15px; } #desktopControls button { padding: 10px 20px; font-size: 1em; background-color: #ff0055; color: #fff; border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 0 10px #ff0055; transition: background-color 0.3s ease; } #desktopControls button:hover { background-color: #e6004c; } @media (max-width: 600px) { #desktopControls { display: flex; justify-content: center; gap: 10px; } canvas { width: 100vw; height: auto; } } #mobileControls { display: none; justify-content: center; gap: 10px; margin-top: 15px; } #mobileControls button { padding: 15px 20px; font-size: 1.2em; background-color: #ff0055; color: #fff; border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 0 10px #ff0055; transition: background-color 0.3s ease; } #mobileControls button:hover { background-color: #e6004c; } @media (max-width: 600px) { #mobileControls { display: none !important; } #desktopControls { display: flex; } } </style> <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet"> </head> <body> <h1>Sp1Dy_Gamerâ„¢ Tetris</h1> <div id="score">Score: 0</div> <div id="level">Level: 0</div> <canvas id="tetris" width="240" height="400"></canvas> <div id="controlsContainer"> <div id="desktopControls"> <button id="pauseButton">Pause Game</button> <button id="restartButton">Restart Game</button> </div> <div id="mobileControls"> <!-- Mobile buttons removed for gesture control --> </div> </div> <div id="branding"> ðŸŽ® Powered by Sp1Dy_Gamerâ„¢ | Subscribe for epic gaming content! </div> <div id="gameOverScreen"> <div id="finalScore">Game Over! Your Score: 0</div> <button id="gameOverRestart">Restart Game</button> </div>

<!-- Audio elements with unique IDs --> <audio id="dropSound" src="drop.mp3"></audio> <audio id="clearSound" src="clear.mp3"></audio> <audio id="gameOverSound" src="gameover.mp3"></audio> <audio id="bgMusic" src="bg.mp3" preload="auto" loop></audio>

<script> const canvas = document.getElementById('tetris'); const context = canvas.getContext('2d'); context.scale(20, 20);

const arena = createMatrix(12, 20);

const player = {
  pos: {x: 0, y: 0},
  matrix: null,
  score: 0,
  paused: false,
  gameOver: false
};

const colors = [
  null,
  '#FF0D72', '#0DC2FF', '#0DFF72',
  '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'
];

function createMatrix(w, h) {
  const matrix = [];
  while (h--) {
    matrix.push(new Array(w).fill(0));
  }
  return matrix;
}

function createPiece(type) {
  const pieces = {
    T: [
      [0, 1, 0],
      [1, 1, 1],
      [0, 0, 0]
    ],
    O: [
      [2, 2],
      [2, 2]
    ],
    L: [
      [0, 3, 0],
      [0, 3, 0],
      [0, 3, 3]
    ],
    J: [
      [0, 4, 0],
      [0, 4, 0],
      [4, 4, 0]
    ],
    I: [
      [0, 5, 0, 0],
      [0, 5, 0, 0],
      [0, 5, 0, 0],
      [0, 5, 0, 0]
    ],
    S: [
      [0, 6, 6],
      [6, 6, 0],
      [0, 0, 0]
    ],
    Z: [
      [7, 7, 0],
      [0, 7, 7],
      [0, 0, 0]
    ],
  };
  return pieces[type];
}

function drawMatrix(matrix, offset) {
  matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        context.fillStyle = colors[value];
        context.fillRect(x + offset.x, y + offset.y, 1, 1);
      }
    });
  });
}

function draw() {
  context.fillStyle = '#000';
  context.fillRect(0, 0, canvas.width, canvas.height);
  drawMatrix(arena, {x:0, y:0});
  drawMatrix(player.matrix, player.pos);
}

function merge(arena, player) {
  player.matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        arena[y + player.pos.y][x + player.pos.x] = value;
      }
    });
  });
}

function collide(arena, player) {
  const [m, o] = [player.matrix, player.pos];
  for (let y = 0; y < m.length; ++y) {
    for (let x = 0; x < m[y].length; ++x) {
      if (m[y][x] !== 0 &&
          (arena[y + o.y] &&
           arena[y + o.y][x + o.x]) !== 0) {
        return true;
      }
    }
  }
  return false;
}

function rotate(matrix, dir) {
  for (let y = 0; y < matrix.length; ++y) {
    for (let x = 0; x < y; ++x) {
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if (dir > 0) matrix.forEach(row => row.reverse());
  else matrix.reverse();
}

function playerDrop() {
  if (player.paused || player.gameOver) return;
  player.pos.y++;
  if (collide(arena, player)) {
    player.pos.y--;
    merge(arena, player);
    document.getElementById('dropSound').play();
    playerReset();
    arenaSweep();
    updateScore();
  }
  dropCounter = 0;
}

function playerMove(dir) {
  if (player.paused || player.gameOver) return;
  player.pos.x += dir;
  if (collide(arena, player)) player.pos.x -= dir;
}

function playerRotate(dir) {
  if (player.paused || player.gameOver) return;
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix, dir);
  while (collide(arena, player)) {
    player.pos.x += offset;
    offset = -(offset + (offset > 0 ? 1 : -1));
    if (offset > player.matrix[0].length) {
      rotate(player.matrix, -dir);
      player.pos.x = pos;
      return;
    }
  }
}

function playerReset() {
  const pieces = 'TJLOSZI';
  player.matrix = createPiece(pieces[Math.floor(Math.random() * pieces.length)]);
  player.pos.y = 0;
  player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
  if (collide(arena, player)) {
    arena.forEach(row => row.fill(0));
    player.gameOver = true;
    player.paused = true;
    document.getElementById('gameOverSound').play();
    showGameOverScreen();
  }
}

function arenaSweep() {
  let rowCount = 1;
  outer: for (let y = arena.length - 1; y >= 0; y--) {
    for (let x = 0; x < arena[y].length; x++) {
      if (arena[y][x] === 0) continue outer;
    }
    const row = arena.splice(y, 1)[0].fill(0);
    arena.unshift(row);
    player.score += rowCount * 10;
    document.getElementById('clearSound').play();
    rowCount *= 2;
  }
}

function updateScore() {
  document.getElementById('score').innerText = 'Score: ' + player.score;
  updateLevel();
}

let level = 0;
let dropInterval = 250;

function updateLevel() {
  level = Math.floor(player.score / 100);
  dropInterval = Math.max(250 - level * 20, 100);
  document.getElementById('level').innerText = 'Level: ' + level;
}

let dropCounter = 0;
let lastTime = 0;

function update(time = 0) {
  if (!player.paused && !player.gameOver) {
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;
    if (dropCounter > dropInterval) playerDrop();
  }
  draw();
  requestAnimationFrame(update);
}

// Start background music on user interaction for mobile
function startBackgroundMusic() {
  const bgMusic = document.getElementById('bgMusic');
  if (bgMusic.paused) {
    bgMusic.play().catch(() => {});
  }
}

document.addEventListener('keydown', () => {
  startBackgroundMusic();
});

document.getElementById('tetris').addEventListener('touchstart', () => {
  startBackgroundMusic();
});

document.getElementById('controlsContainer').addEventListener('touchstart', () => {
  startBackgroundMusic();
});

document.addEventListener('keydown', event => {
  if (player.paused || player.gameOver) return;
  if (event.key === 'ArrowLeft') playerMove(-1);
  else if (event.key === 'ArrowRight') playerMove(1);
  else if (event.key === 'ArrowDown') playerDrop();
  else if (event.key === 'ArrowUp') playerRotate(1);
});

document.getElementById('restartButton').addEventListener('click', () => {
  resetGame();
});

document.getElementById('pauseButton').addEventListener('click', () => {
  if (player.gameOver) return;
  player.paused = !player.paused;
  document.getElementById('pauseButton').innerText = player.paused ? 'Resume Game' : 'Pause Game';
});

// Game Over screen restart button
document.getElementById('gameOverRestart').addEventListener('click', () => {
  hideGameOverScreen();
  resetGame();
});

// Gesture controls for mobile
let touchStartX = null;
let touchStartY = null;
let touchStartTime = 0;

canvas.addEventListener('touchstart', e => {
  if (player.paused || player.gameOver) return;
  if (e.touches.length === 1) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchStartTime = Date.now();
  }
});

canvas.addEventListener('touchend', e => {
  if (player.paused || player.gameOver) return;
  if (touchStartX === null || touchStartY === null) return;

  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  const dt = Date.now() - touchStartTime;

  const swipeThreshold = 30; // Minimum distance in px for swipe
  const tapMaxTime = 300; // Max time in ms for tap
  const tapMaxDistance = 10; // Max movement in px for tap

  if (dt < tapMaxTime && Math.abs(dx) < tapMaxDistance && Math.abs(dy) < tapMaxDistance) {
    // Tap detected: rotate piece
    playerRotate(1);
  } else if (Math.abs(dx) > Math.abs(dy)) {
    // Horizontal swipe
    if (dx > swipeThreshold) {
      // Swipe right
      playerMove(1);
    } else if (dx < -swipeThreshold) {
      // Swipe left
      playerMove(-1);
    }
  } else {
    // Vertical swipe
    if (dy > swipeThreshold) {
      // Swipe down
      playerDrop();
    }
  }

  touchStartX = null;
  touchStartY = null;
});

function resetGame() {
  arena.forEach(row => row.fill(0));
  player.score = 0;
  player.paused = false;
  player.gameOver = false;
  updateScore();
  document.getElementById('pauseButton').innerText = 'Pause Game';
  hideGameOverScreen();
  playerReset();
}

function showGameOverScreen() {
  const screen = document.getElementById('gameOverScreen');
  const scoreDisplay = document.getElementById('finalScore');
  scoreDisplay.textContent = 'Game Over! Your Score: ' + player.score;
  screen.style.display = 'block';
}

function hideGameOverScreen() {
  document.getElementById('gameOverScreen').style.display = 'none';
}

playerReset();
update();

</script> </body> </html>
